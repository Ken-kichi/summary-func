# 【完全ガイド】AI要約アプリをゼロからAzureにデプロイ
## 初心者エンジニア必見！セットアップからCI/CD構築まで

---

## はじめに

平日の朝に生成AIを使ってAI/テクノロジー系のニュースを解説する記事を書いています。プロンプトのテンプレートを作成して記事を書く方法を会社で発表したところ、「生成AIを使う流れはわかったが、ツールの使い方などでつまずいてうまく自分が表現したい記事が書けない」という声をいただきました。

そこで、解説したいニュース記事をペーストするだけで解説記事が書けるアプリを作ってみればどうかと思い、このガイドを書き始めました。**自分でニュースを集め、要点をAIに抽出させ、Mermaidで図解し、最後はAzureにデプロイする**—そんな一連の流れを初心者エンジニアでも踏破できるように丁寧に分解しています。

このガイドでは、**Azure OpenAIを使った新聞記事要約アプリ**を、セットアップからAzureへのデプロイまで、完全に構築する方法をお伝えします。

- ✅ **対象者**: 初心者エンジニア、Pythonの基本知識がある方
- ✅ **所要時間**: 約2〜3時間（環境構築を含む）
- ✅ **難易度**: ★★★☆☆（中級）
- ✅ **最終的な成果**: Azure App ServiceでホストされたAI要約アプリ

このアプリには以下の特徴があります：

1. **Azure OpenAI（gpt-5.1-chat）** による高精度な要約生成
2. **自動図解生成** - Mermaidで記事内容を可視化
3. **GitHub Actionsによる自動デプロイ** - pushするだけで本番反映
4. **スケーラブルなインフラ** - 初期コスト0円で始める

### この記事で到達するゴール

初心者エンジニアが迷子になりがちなポイントを、以下の3フェーズに分けて解説します。

- **Phase 1: ローカル開発** — FlaskでAPIと画面を作り、Azure OpenAIと繋げる
- **Phase 2: クラウド準備** — Azure App ServiceとAzure OpenAIを安全に構成する
- **Phase 3: 自動デプロイ** — GitHub Actionsでpush→即デプロイを実現する

フェーズごとに「やること / 期待する結果 / つまずきポイント」を整理しているので、途中で止まっても理由を特定しやすくなっています。では、一緒に構築していきましょう！


## 前提条件の確認

このガイドを進める前に、以下が揃っているか確認してください：

### 必須環境

| 項目 | 要件 | 確認方法 |
|------|------|---------|
| **OS** | macOS / Linux / Windows | `uname -s` でOS確認 |
| **Python** | 3.10 以上 | `python3 --version` |
| **pip** | （参考）Python同梱。uv利用時のトラブルシュート用 | `pip --version` |
| **Git** | インストール済み | `git --version` |
| **Node.js** | 16 以上 | `node --version` |
| **npm** | 最新版 | `npm --version` |
| **uv** | 最新版 | `uv --version` |

> ℹ️ Pythonパッケージのインストールは pip ではなく uv で行います（pip はPythonに同梱されていますが、このプロジェクトでは使用しません）。

### アカウント

- ✅ **Azureアカウント** - 無料トライアル（¥22,500クレジット）でOK
- ✅ **GitHubアカウント** - リポジトリのホスト用
- ✅ **Azure OpenAIへのアクセス** - 事前申し込みが必要な場合あり

### インストール確認

```bash
# 全てを一度に確認する場合
python3 --version && git --version && node --version && npm --version && uv --version
```

**出力例：**
```
Python 3.10.4
git version 2.41.0
v18.17.1
9.6.7
uv 0.7.8 (0ddcc1905 2025-05-23)
```

---

## Step 1: 開発環境のセットアップ

### 1-1. プロジェクトディレクトリの準備

まず、プロジェクトディレクトリを作成します。

```bash
# ホームディレクトリに移動
cd ~/Desktop

# プロジェクトディレクトリを作成
~/Desktop $ mkdir news-summarizer
~/Desktop $ cd news-summarizer
~/Desktop/news-summarizer $ uv init
```

### 1-2. Python仮想環境の構築

Pythonの仮想環境を作成することで、プロジェクト固有のパッケージをインストールできます。

```bash
# 仮想環境を作成
uv venv

# 仮想環境をアクティベート（macOS/Linux）
source .venv/bin/activate

# Windows の場合
# .venv\Scripts\activate

# アクティベート確認（プロンプトに(.venv)が表示されたらOK）
```

**期待される出力：**
```
(news-summarizer) ~/Desktop/news-summarizer $
```

### 1-3. Pythonの必要パッケージをインストール

このプロジェクトでは、Pythonパッケージはpipではなく**uv**で管理します。uvはpip互換のCLIを提供するため、同じ感覚で利用できますが、インストールやロックファイルの生成が高速です。

```bash
# uv を最新化（任意）
uv self update

# requirements.txtを作成（後ほど詳細に説明）
~/Desktop/news-summarizer $ uv add Flask python-dotenv langchain langchain-openai openai requests

# 依存パッケージをインストール
uv pip install -r requirements.txt
```

**インストール確認：**
```bash
uv pip list | grep -E "Flask|langchain|openai"
```

### 1-4. Node.jsおよびMermaid CLIのインストール

図解機能に必要な Mermaid CLI をインストールします。

```bash
# Mermaid CLI をグローバルインストール
npm install -g @mermaid-js/mermaid-cli

# インストール確認
mmdc --version

# 期待される出力例: mermaid-cli 10.6.1
```

**トラブル:** `mmdc: command not found` が表示される場合
```bash
# npm の グローバルパスを確認
npm config get prefix

# 出力例: /usr/local/Cellar/node/18.18.0/libexec/npm
# この場所に mmdc がインストールされます
```

### 1-5. ディレクトリ構造を整える

プロジェクトに必要なフォルダとファイルを作成します。

```bash
# ディレクトリ構造
mkdir -p templates static .github/workflows

```

**作成後の構造：**
```
news-summarizer/
├── .venv/                    # 仮想環境（自動作成）
├── .github/workflows/        # GitHub Actions設定
├── static/                   # フロントエンドファイル
│   ├── main.js
│   └── styles.css
├── templates/                # HTMLテンプレート
│   └── index.html
├── main.py                   # Flask アプリケーション
├── requirements.txt          # Python 依存パッケージ
├── .env                      # 環境変数（ローカル用）
└── .gitignore                # Git除外ファイル
```

### 1-6. 初心者チェックポイント

> ここまで完了したら、後工程に進む前に次のポイントを簡単にセルフチェックしてください。初学者がつまずきやすい場所を先回りで潰しておくと、AzureデプロイやCI/CDまで一気に駆け抜けられます。

- **仮想環境が有効化されているか**: macOS/Linuxは `source .venv/bin/activate`、PowerShellは `.\.venv\Scripts\Activate.ps1`。プロンプト頭に `(.venv)` が出ていれば成功です。
- **uvで依存関係を入れているか**: `uv pip list | head` を実行し、Flask や langchain が表示されるか確認します。`pip` コマンドは使わないよう注意。
- **requirements.txt / uv.lock をGit管理に含めたか**: 依存関係の再現性を担保するため、`git status --short | grep 'requirements.txt\|uv.lock'` で追跡対象になっているか確認します。
- **.envがバージョン管理から外れているか**: `git status --short | grep .env` で表示される場合は `git rm --cached .env` を実行し、秘密情報の漏洩を防ぎます。
- **Node.js / Mermaid CLI の確認**: `node --version` と `mmdc --version` が通るかチェック。後半の図解生成ワークフローで突然つまずくのを防げます。


## Step 2: Azure環境の準備

ここからはAzure Portalを使用して、クラウドインフラを構築します。

> **事前メモ**: Azure のリソース名はサブスクリプション内またはグローバルで一意である必要があります。`news-summarizer-app` が既に使われている場合は、GitHubユーザー名などを付けて `yourname-news-summarizer-app` のように変更しましょう。また、以降で作成するすべてのリソースは同じサブスクリプション/リージョンを選んで揃えておくと、料金やアクセス制御のトラブルを避けられます。作成したリソース名とリージョンはメモアプリに控えておくのがおすすめです。

### 2-1. Azureアカウントの準備

1. [Azure公式サイト](https://azure.microsoft.com/ja-jp/)にアクセス
2. **無料アカウントを作成**をクリック
3. Microsoft アカウントでサインアップ（Gmailなどでも可）
4. ¥22,500のクレジットが付与されます（3ヶ月有効）

### 2-2. Azure Portalでリソースグループを作成

**リソースグループ**は、関連するAzureリソースを管理するための論理的な単位です。

**手順：**

1. [Azure Portal](https://portal.azure.com/)にサインイン
2. 左のメニューから**リソースグループ**を選択
3. **作成**をクリック
4. 以下を入力：
   - **リソースグループ名**: `news-summarizer-rg`
   - **リージョン**: `東日本（Tokyo）`または`日本東部`を選択
5. **確認および作成**→**作成**をクリック

### 2-3. App Service プランを作成

App Service プランは、アプリケーションをホストするコンピュートリソースの定義です。

**手順：**

1. Azure Portalで**App Service プラン**を検索
2. **作成**をクリック
3. 以下を入力：
   - **リソースグループ**: `news-summarizer-rg`（先ほど作成したもの）
   - **名前**: `news-summarizer-plan`
   - **オペレーティングシステム**: `Linux`を選択
   - **リージョン**: `東日本（Tokyo）`
   - **価格レベル**: `Free F1` ← **重要！無料枠です**

4. **確認および作成**→**作成**をクリック

| 価格レベル | 月額 | 用途 |
|-----------|-----|------|
| **Free (F1)** | ¥0 | 開発・テスト（推奨） |
| Basic (B1) | ¥約1,400 | 小規模本番 |
| Standard (S1) | ¥約3,800 | 中規模本番 |

### 2-4. App Service（ウェブアプリ）を作成

最後に、アプリケーション本体をホストするApp Serviceを作成します。

**手順：**

1. Azure Portalで**App Service**を検索
2. **作成** → **Web アプリ**をクリック
3. 以下を入力：
   - **リソースグループ**: `news-summarizer-rg`
   - **名前**: `news-summarizer-app`
     （例: `news-summarizer-app`）
     ※名前は全Azure内でユニークである必要があります
   - **公開**: `コード`を選択
   - **ランタイムスタック**: `Python 3.11`を選択
   - **オペレーティングシステム**: `Linux`
   - **リージョン**: `東日本（Tokyo）`
   - **App Service プラン**: `news-summarizer-plan`

4. **確認および作成**→**作成**をクリック

### 2-5. Azure OpenAIのセットアップ

AI要約機能に必要な Azure OpenAI リソースを作成します。

**手順：**

1. Azure Portalで**Azure OpenAI**を検索
2. **作成**をクリック
3. 以下を入力：
   - **リソースグループ**: `news-summarizer-rg`
   - **名前**: `news-summarizer-openai`
   - **リージョン**: `East US`（重要！gpt-5.1-chatは限定リージョンのみ対応）
   - **価格レベル**: `Standard S0`

4. **確認および作成**→**作成**をクリック

**⚠️ 重要な注意：**

- Azure OpenAIは**事前申し込みが必要**な場合があります
- 既存のAzureアカウントで十分なクレジットがあれば利用可能
- 作成に**数分〜数時間**かかる場合があります

### 2-6. Azure OpenAIにモデルをデプロイ

OpenAIリソース作成後、gpt-5.1-chatモデルをデプロイします。

**手順：**

1. 作成した「news-summarizer-openai」リソースを開く
2. 画面下部の**Explore Foundry portal**をクリック
3. 左サイドメニューの**モデルカタログ**をクリック
4. モデルカタログから**gpt-5.1-chat**を選択
5. **このモデルを使用する**をクリック
6. デプロイの設定を確認し、**デプロイ**をクリック

**デプロイ完了後：**

- **Endpoint**（例: `https://news-summarizer-openai.openai.azure.com/`）
- **API Key**（例: `a1b2c3d4...`）
- **Model name**（デプロイ名: `gpt-5.1-chat`）
- **API version**（例: `2024-02-15-preview`）

これら4つの情報は後ほど必要になります。

## Step 3: ローカルで動作確認

ここからは、ローカル環境でアプリケーションを実装し、テストします。

### 3-1. Flask アプリケーションを実装

ここからは**バックエンド（Flask）**を仕上げます。構成はシンプルですが、役割をはっきり分けると初心者でも追いやすくなります。

| レイヤー | 役割 | 代表ファイル/ライブラリ | 失敗したときに起こること |
|----------|------|------------------------|--------------------------|
| ルーティング (`/`, `/summarize` など) | ブラウザからのリクエストを受け取り、処理を振り分ける | Flask (`from flask import ...`) | URL が 404 になる、JSON が返らない |
| LLM 呼び出し | Azure OpenAI に要約生成を依頼 | `AzureChatOpenAI`, `ChatPromptTemplate` | API キー/エンドポイントが間違っていると 401/404 |
| Mermaid 抽出/変換 | 要約結果から ```mermaid``` を抜き出し PNG 変換 | `re` / `subprocess` / `tempfile` | Mermaid が見つからない or mmdc 実行に失敗 |
| 出力整形 | Markdown/PNG をユーザーに返す | `send_file`, `BytesIO` | ダウンロードボタンが動かない |

こうして責務を切っておくと、「どこで止まっているのか」をログやエラーメッセージから逆算しやすくなります。では実際のコードを見ていきます。

`main.py`を以下のように作成します。

```python:main.py
from flask import Flask, render_template, request, jsonify, send_file
from langchain_openai.chat_models import AzureChatOpenAI
from langchain_core.prompts import SystemMessagePromptTemplate
from langchain_core.prompts.chat import ChatPromptTemplate
import os
import re
import subprocess
import tempfile
from io import BytesIO
from dotenv import load_dotenv

load_dotenv()
DEVELOPMENT = os.getenv("DEVELOPMENT")
API_VERSION = os.getenv("API_VERSION")
ENDPOINT = os.getenv("ENDPOINT")
SUBSCRIPTION_KEY = os.getenv("SUBSCRIPTION_KEY")
MODEL_NAME = os.getenv("MODEL_NAME")


app = Flask(__name__)


@app.route('/')
def index():
    return render_template('index.html')


@app.route('/summarize', methods=['POST'])
def summarize():
    try:
        data = request.json
        news_text = data.get('news_text', '')

        if not news_text:
            return jsonify({'error': 'ニュースの本文を入力してください'}), 400

        model = AzureChatOpenAI(
            api_version=API_VERSION,
            azure_endpoint=ENDPOINT,
            api_key=SUBSCRIPTION_KEY,
            model_name=MODEL_NAME
        )

        template = """以下のニュース記事を要約してください。要約はMarkdown形式で出力してください。
            要約には以下の要素を含めてください：
            - タイトル（見出し1）
            - 要点（箇条書き）
            - 詳細な要約（段落形式）
            - mermaidで記事の内容を図解

            ニュース記事：
            {news_text}"""

        system_prompt = SystemMessagePromptTemplate.from_template(template)
        chain_prompt = ChatPromptTemplate.from_messages([system_prompt])

        chain = chain_prompt | model

        result = chain.invoke({"news_text": news_text})

        summary = result.content

        return jsonify({'summary': summary})

    except Exception as e:
        return jsonify({'error': f'エラーが発生しました: {str(e)}'}), 500


@app.route('/download', methods=['POST'])
def download():
    try:
        data = request.json
        summary = data.get('summary', '')

        if not summary:
            return jsonify({'error': '要約が見つかりません'}), 400

        # Markdownファイルとしてダウンロード
        buffer = BytesIO()
        buffer.write(summary.encode('utf-8'))
        buffer.seek(0)

        return send_file(
            buffer,
            as_attachment=True,
            download_name='news_summary.md',
            mimetype='text/markdown'
        )

    except Exception as e:
        return jsonify({'error': f'エラーが発生しました: {str(e)}'}), 500


@app.route('/extract-mermaid', methods=['POST'])
def extract_mermaid():
    try:
        data = request.json
        summary = data.get('summary', '')

        if not summary:
            return jsonify({'error': '要約が見つかりません'}), 400

        # Markdownからmermaidコードブロックを抽出
        mermaid_pattern = r'```mermaid\n(.*?)\n```'
        matches = re.findall(mermaid_pattern, summary, re.DOTALL)

        if not matches:
            return jsonify({'error': 'mermaid図解が見つかりません'}), 400

        return jsonify({'mermaid_diagrams': matches, 'count': len(matches)})

    except Exception as e:
        return jsonify({'error': f'エラーが発生しました: {str(e)}'}), 500


@app.route('/convert-mermaid-png', methods=['POST'])
def convert_mermaid_png():
    """
    Mermaidコードを PNG に変換
    ※ Azure App Service では mmdc が利用できないため、ブラウザ側で処理することを推奨
    """
    try:
        import shutil

        data = request.json
        mermaid_code = data.get('mermaid_code', '')
        diagram_index = data.get('diagram_index', 0)

        if not mermaid_code:
            return jsonify({'error': 'mermaidコードが見つかりません'}), 400

        # mmdc コマンドが利用可能か確認
        mmdc_path = shutil.which('mmdc')
        if not mmdc_path:
            return jsonify({
                'error': 'Mermaid CLI がこの環境では利用できません。ローカル環境でのみ使用可能です。',
                'available_on_local': True,
                'mermaid_code': mermaid_code
            }), 501  # Not Implemented

        # 一時ファイルを作成
        with tempfile.NamedTemporaryFile(mode='w', suffix='.mmd', delete=False) as f:
            f.write(mermaid_code)
            mmd_file = f.name

        try:
            # mmdc (mermaid-cli) を使用してPNGに変換
            png_file = mmd_file.replace('.mmd', '.png')
            subprocess.run(
                ['mmdc', '-i', mmd_file, '-o', png_file, '-s', '2'],
                check=True,
                capture_output=True,
                timeout=30
            )

            # PNGファイルを読み込んでバイナリで返す
            with open(png_file, 'rb') as f:
                png_data = f.read()

            buffer = BytesIO(png_data)
            buffer.seek(0)

            return send_file(
                buffer,
                mimetype='image/png',
                as_attachment=True,
                download_name=f'diagram_{diagram_index + 1}.png'
            )

        finally:
            # 一時ファイルをクリーンアップ
            if os.path.exists(mmd_file):
                os.remove(mmd_file)
            if os.path.exists(png_file):
                os.remove(png_file)

    except subprocess.CalledProcessError as e:
        return jsonify({'error': f'mermaid変換エラー: {e.stderr.decode() if e.stderr else str(e)}'}), 500
    except Exception as e:
        return jsonify({'error': f'エラーが発生しました: {str(e)}'}), 500


if __name__ == '__main__':
    import sys
    # Azure App Service での実行に対応
    port = int(os.environ.get('PORT', 5000))
    debug_mode = os.environ.get('FLASK_ENV') == 'development'
    app.run(host='0.0.0.0', port=port, debug=debug_mode)
```

#### バックエンド実装のポイントと意図

- **`load_dotenv()` で環境変数を読み込む理由**: APIキーやエンドポイントをコードに直書きすると、GitHubにpushした瞬間に漏えいします。`.env`+`.gitignore`の組み合わせは初心者でも再利用しやすいベストプラクティスなので、必ず冒頭で読み込んでいます。
- **`AzureChatOpenAI` の採用**: LangChainのAzure向けラッパーを使うことで `api_version` や `azure_endpoint` を都度指定できます。素の `openai` パッケージを使うより設定忘れが起きにくく、設定漏れがあると 401/404 で即エラーになる点も理解しやすいです。
- **プロンプトテンプレート固定の重要性**: `SystemMessagePromptTemplate` で Markdown 出力を強制しています。これを入れないと、LLM が見出しや箇条書きを返さず、フロント側の Markdown パーサーが崩れます。
- **Mermaid 抽出/変換の二段構成**: `/extract-mermaid` で正規表現により ```mermaid``` ブロックのみを抽出し、`/convert-mermaid-png` でPNG化しています。1本のAPIで同時にやると、図解生成に失敗しただけで要約全体までロールバックしてしまうためです。
- **`shutil.which('mmdc')` チェック**: Azure App Service では `mmdc` が入っていないことが多いので、利用可能かを最初に判定し、なければ 501 を返して「ローカルで変換してね」と伝えています。存在チェックをしないと、存在しないコマンドを叩き続けてアプリ全体がクラッシュします。
- **`host='0.0.0.0'` とポートの外だし**: ローカルなら `localhost` 固定でも動きますが、クラウドでは外部から接続できなくなります。`PORT` を環境変数から読むようにしないと、App Service のヘルスチェックが通らずデプロイ失敗になる点もセットで覚えておきましょう。

#### デプロイ用エントリポイント `app.py`

Azure App Service はリポジトリ直下にある WSGI エントリポイントを探しに来るため、`main.py` とは別に薄いラッパーファイルを置いておきます。

```python
"""
WSGI entry point for Azure App Service
"""
from main import app

if __name__ == '__main__':
    app.run()
```

- **役割**: `main.py` で定義した `app` オブジェクトを Azure 側に公開するだけのファイルです。App Service のデフォルトパスは `app:app` を期待するので、名前を合わせると追加設定なしで読み込んでくれます。
- **なぜ分けるのか**: `main.py` で `if __name__ == '__main__'` 以下にデバッグサーバー起動を書いているため、そのままインポートすると副作用（デバッグ実行）が走ります。`app.py` を用意しておくと、本番環境では `gunicorn app:app` のように安全に参照できます。
- **置かないとどうなるか**: App Service が Flask アプリを見つけられず、`Your app service is up, but your app is not responding` といった 500 エラーになります。`startup command` で明示的に `gunicorn wsgi:app` を指定する方法もありますが、`app.py` を1枚置く方が初心者には分かりやすいです。

### 3-2. フロントエンド（HTML/CSS/JavaScript）を実装

バックエンドが用意できたら、ユーザーが触れる画面を作ります。フロントエンドは以下の3ファイルの連携です。

| ファイル | 役割 | 注目ポイント |
|----------|------|--------------|
| `templates/index.html` | UI の骨格を定義。Flask の `render_template` から配信 | `textarea` と結果パネルを2カラムに分け、フォーム送信はすべて JS に任せる |
| `static/styles.css` | ガラスモーフィズム風のスタイルで視認性を担保 | `@media` クエリでスマホにも対応、Markdown 表示部分の余白調整 |
| `static/main.js` | API 呼び出し、Markdown 描画、Mermaid 抽出/変換ボタン | jQuery で DOM/イベント/AJAX を統一管理し、`marked` で Markdown をレンダリング |

「データはバックエンド、表示はフロントエンド」と割り切り、フォームの `action` を使わずすべて JavaScript から API を叩く設計にしている点が肝です。

#### HTML: `templates/index.html`

```html:templates/index.html
<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ニュース要約アプリ</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- pako 圧縮用（Mermaid Live 用） -->
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"
        integrity="sha256-eKhayi6qVizyotHqlLy7Wd9Jd6M16w1Jb8OTnTv8qHE=" crossorigin="anonymous"></script>

    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>

<body>
    <div class="container">
        <h1>📰 ニュース要約アプリ</h1>

        <div class="main-content">
            <div class="panel">
                <h2>ニュース本文を入力</h2>
                <textarea id="newsInput" placeholder="ニュースの全文をここに貼り付けてください..."></textarea>
                <div class="button-group">
                    <button class="btn-primary" id="summarizeBtn">要約する</button>
                </div>
            </div>

            <div class="panel">
                <h2>要約結果</h2>
                <div id="summaryOutput">
                    <div class="placeholder">要約結果がここに表示されます</div>
                </div>
                <div class="button-group">
                    <button class="btn-secondary" id="downloadBtn" disabled>Markdownをダウンロード</button>
                    <button class="btn-secondary" id="downloadDiagramBtn" disabled
                        style="background: linear-gradient(135deg, rgba(34, 197, 94, 0.5), rgba(59, 130, 246, 0.5));">
                        Mermaid Editor で開く
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script src="{{ url_for('static', filename='main.js') }}"></script>
</body>

</html>

```

#### CSS: `static/styles.css`

背景には Unsplash からダウンロードした高解像度写真（例: `static/unsplash.jpg`）を置き、`background-image` で読み込んでいます。`static` フォルダ直下に好みの写真を保存し、著作権表記が必要な場合は README 等にクレジットを追記してください。

```css:static/styles.css

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', sans-serif;
    background-image: url("./unsplash.jpg");
    background-size: cover;
    background-position: center;
    background-attachment: fixed;
    background-repeat: no-repeat;
    min-height: 100vh;
    padding: 40px 20px;
    position: relative;
    overflow-x: hidden;
}

/* 背景のオーバーレイ（コントラスト向上のため） */
body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.3);
    z-index: 0;
}

.container {
    max-width: 1400px;
    margin: 0 auto;
    position: relative;
    z-index: 1;
}

h1 {
    color: white;
    text-align: center;
    margin-bottom: 40px;
    font-size: 3em;
    font-weight: 700;
    letter-spacing: -1px;
    text-shadow: 0 2px 20px rgba(0, 0, 0, 0.2);
}

.main-content {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 30px;
    margin-bottom: 20px;
}

.panel {
    background: rgba(255, 255, 255, 0.15);
    backdrop-filter: blur(20px) saturate(180%);
    -webkit-backdrop-filter: blur(20px) saturate(180%);
    border-radius: 24px;
    padding: 32px;
    box-shadow:
        0 8px 32px 0 rgba(31, 38, 135, 0.37),
        inset 0 1px 0 0 rgba(255, 255, 255, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.25);
    transition: all 0.3s ease;
}

.panel:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-2px);
    box-shadow:
        0 12px 40px 0 rgba(31, 38, 135, 0.45),
        inset 0 1px 0 0 rgba(255, 255, 255, 0.5);
}

.panel h2 {
    color: white;
    margin-bottom: 20px;
    font-size: 1.5em;
    font-weight: 600;
    letter-spacing: -0.5px;
}

textarea {
    width: 100%;
    height: 420px;
    padding: 20px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 16px;
    font-size: 15px;
    font-family: inherit;
    resize: vertical;
    transition: all 0.3s;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    color: white;
    line-height: 1.6;
}

textarea::placeholder {
    color: rgba(255, 255, 255, 0.6);
}

textarea:focus {
    outline: none;
    border-color: rgba(255, 255, 255, 0.4);
    background: rgba(255, 255, 255, 0.15);
    box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.1);
}

.button-group {
    display: flex;
    gap: 12px;
    margin-top: 20px;
}

button {
    flex: 1;
    padding: 16px 32px;
    border: none;
    border-radius: 14px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    letter-spacing: 0.3px;
    position: relative;
    overflow: hidden;
}

button::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
    transform: translateX(-100%);
    transition: transform 0.6s;
}

button:hover::before {
    transform: translateX(100%);
}

.btn-primary {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.2));
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.4);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
}

.btn-primary:hover:not(:disabled) {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0.3));
    transform: translateY(-2px);
    box-shadow: 0 6px 24px rgba(0, 0, 0, 0.3);
}

.btn-primary:active:not(:disabled) {
    transform: translateY(0);
}

.btn-primary:disabled {
    background: rgba(255, 255, 255, 0.1);
    cursor: not-allowed;
    opacity: 0.5;
}

.btn-secondary {
    background: linear-gradient(135deg, rgba(118, 75, 162, 0.5), rgba(102, 126, 234, 0.5));
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
}

.btn-secondary:hover:not(:disabled) {
    background: linear-gradient(135deg, rgba(118, 75, 162, 0.6), rgba(102, 126, 234, 0.6));
    transform: translateY(-2px);
    box-shadow: 0 6px 24px rgba(0, 0, 0, 0.3);
}

.btn-secondary:active:not(:disabled) {
    transform: translateY(0);
}

.btn-secondary:disabled {
    background: rgba(255, 255, 255, 0.1);
    cursor: not-allowed;
    opacity: 0.5;
}

#summaryOutput {
    min-height: 420px;
    padding: 24px;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: white;
}

#summaryOutput h1 {
    color: white;
    text-align: left;
    font-size: 2em;
    font-weight: 700;
    margin: 20px 0 15px 0;
    text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
}

#summaryOutput h2 {
    color: rgba(255, 255, 255, 0.95);
    font-size: 1.5em;
    font-weight: 600;
    margin: 20px 0 12px 0;
}

#summaryOutput ul {
    margin-left: 24px;
    margin-bottom: 16px;
}

#summaryOutput li {
    margin: 10px 0;
    line-height: 1.7;
    color: rgba(255, 255, 255, 0.9);
}

#summaryOutput p {
    line-height: 1.8;
    margin-bottom: 16px;
    color: rgba(255, 255, 255, 0.9);
}

#summaryOutput code {
    background: rgba(0, 0, 0, 0.2);
    padding: 2px 8px;
    border-radius: 6px;
    font-family: 'SF Mono', Menlo, Monaco, monospace;
}

.loading {
    text-align: center;
    padding: 80px 20px;
}

.spinner {
    width: 60px;
    height: 60px;
    margin: 0 auto 24px;
    border: 4px solid rgba(255, 255, 255, 0.2);
    border-top: 4px solid rgba(255, 255, 255, 0.8);
    border-radius: 50%;
    animation: spin 1s cubic-bezier(0.5, 0, 0.5, 1) infinite;
}

@keyframes spin {
    0% {
        transform: rotate(0deg);
    }

    100% {
        transform: rotate(360deg);
    }
}

.loading-text {
    color: white;
    font-size: 18px;
    font-weight: 500;
}

.error {
    background: rgba(239, 68, 68, 0.2);
    backdrop-filter: blur(10px);
    color: white;
    padding: 20px;
    border-radius: 12px;
    border: 1px solid rgba(239, 68, 68, 0.4);
}

.placeholder {
    color: rgba(255, 255, 255, 0.5);
    text-align: center;
    padding: 80px;
    font-size: 16px;
    font-weight: 500;
}

.diagram-btn {
    padding: 10px 16px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 10px;
    background: rgba(59, 130, 246, 0.3);
    color: white;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.2s ease;
}

.diagram-btn:hover {
    background: rgba(59, 130, 246, 0.5);
    border-color: rgba(255, 255, 255, 0.5);
}

.diagram-btn:active {
    background: rgba(59, 130, 246, 0.6);
}

@media (max-width: 1024px) {
    .main-content {
        grid-template-columns: 1fr;
    }

    h1 {
        font-size: 2.5em;
    }
}

@media (max-width: 768px) {
    body {
        padding: 20px 16px;
    }

    h1 {
        font-size: 2em;
        margin-bottom: 30px;
    }

    .panel {
        padding: 24px;
    }

    textarea,
    #summaryOutput {
        min-height: 320px;
    }
}

```

#### JavaScript: `static/main.js`

```javascript:static/main.js
/**
 * ニュース要約ページのフロント処理。
 * jQuery を使い、フォーム送信・要約結果描画・Markdown ダウンロードを制御する。
 */
let currentSummary = '';
let mermaidDiagrams = [];

$(function () {
    const $newsInput = $('#newsInput');
    const $summaryOutput = $('#summaryOutput');
    const $summarizeBtn = $('#summarizeBtn');
    const $downloadBtn = $('#downloadBtn');
    const $downloadDiagramBtn = $('#downloadDiagramBtn');

    const setLoadingView = () => {
        $summaryOutput.html(`
            <div class="loading">
                <div class="spinner"></div>
                <div class="loading-text">要約を生成中...</div>
            </div>
        `);
    };

    const resetButtons = () => {
        $summarizeBtn.prop('disabled', false);
        $downloadBtn.prop('disabled', !currentSummary);
        $downloadDiagramBtn.prop('disabled', mermaidDiagrams.length === 0);
    };

    async function summarize() {
        const newsText = $newsInput.val().trim();

        if (!newsText) {
            $summaryOutput.html('<div class="error">ニュースの本文を入力してください</div>');
            return;
        }

        setLoadingView();
        $summarizeBtn.prop('disabled', true);
        $downloadBtn.prop('disabled', true);
        $downloadDiagramBtn.prop('disabled', true);

        try {
            const data = await $.ajax({
                url: '/summarize',
                method: 'POST',
                contentType: 'application/json',
                dataType: 'json',
                data: JSON.stringify({ news_text: newsText }),
                processData: false
            });

            currentSummary = data.summary || '';
            $summaryOutput.html(marked.parse(currentSummary));
            $downloadBtn.prop('disabled', !currentSummary);

            try {
                const extractData = await $.ajax({
                    url: '/extract-mermaid',
                    method: 'POST',
                    contentType: 'application/json',
                    dataType: 'json',
                    data: JSON.stringify({ summary: currentSummary }),
                    processData: false
                });

                mermaidDiagrams = extractData.mermaid_diagrams || [];

                if (mermaidDiagrams.length > 0) {
                    $downloadDiagramBtn
                        .prop('disabled', false)
                        .text('Mermaid Editor を開く');
                }
            } catch (extractError) {
                console.error('Mermaid extraction failed', extractError);
            }
        } catch (error) {
            const message = error?.responseJSON?.error || error?.statusText || 'エラーが発生しました';
            $summaryOutput.html(`<div class="error">${message}</div>`);
        } finally {
            resetButtons();
        }
    }

    async function downloadMarkdown() {
        if (!currentSummary) {
            alert('要約がありません');
            return;
        }

        try {
            const blob = await $.ajax({
                url: '/download',
                method: 'POST',
                contentType: 'application/json',
                data: JSON.stringify({ summary: currentSummary }),
                processData: false,
                xhrFields: { responseType: 'blob' }
            });

            const url = window.URL.createObjectURL(blob);
            const $tempLink = $('<a>', {
                href: url,
                download: 'news_summary.md',
                style: 'display:none'
            }).appendTo('body');

            $tempLink[0].click();
            $tempLink.remove();
            window.URL.revokeObjectURL(url);
        } catch (error) {
            const message = error?.responseJSON?.error || 'エラーが発生しました';
            alert(message);
        }
    }

    function openMermaidLive() {
        window.open('https://mermaid.live/edit', '_blank');
    }

    $summarizeBtn.on('click', summarize);
    $downloadBtn.on('click', downloadMarkdown);
    $downloadDiagramBtn.on('click', openMermaidLive);

    $newsInput.on('keydown', function (e) {
        if (e.ctrlKey && e.key === 'Enter') {
            summarize();
        }
    });
});

```

#### フロントエンド実装のポイントと意図

- **HTMLで入力/出力パネルを分離**: 同じ画面に入力フォームと要約結果を並べることで、「入力→AI→出力」の流れが視覚的に追いやすくなります。ページを分ける実装だと状態管理が増え、初心者ほど JavaScript 側のバグで詰まりやすいので、この構成を勧めています。
- **`marked.js` の読み込み**: バックエンドが Markdown を返す前提なので、クライアント側で HTML へ即変換しています。これを入れないと `# 見出し` や `- 箇条書き` がそのままテキスト表示になり、せっかく整えたプロンプトの形式が崩れます。
- **CSS の `disabled`／ローディング表示**: API 呼び出し中はボタンを無効化・インジケータを表示し、二重送信を防いでいます。これをしないとユーザーが連打してしまい、Azure OpenAI のレート制限で429が返ってアプリが止まります。
- **`currentSummary` のグローバル状態**: 最新の要約テキストをブラウザ側に保持し、ダウンロードや図解抽出時にサーバーへ再度本文を送らなくても済むようにしています。ここが空のままだと `/download` に空文字を送って400エラーになりがちです。
- **jQuery でイベント/AJAX を統一**: フォーム送信、ボタン制御、API 呼び出しをすべて jQuery に寄せることで、DOM 取得やエラーハンドリングの書き方を一本化しています。`$.ajax` なら JSON 送信とレスポンスの変換をまとめて記述でき、初心者でも処理の流れを追いやすくなります。
- **Mermaid Editor ボタンの有効化**: `/extract-mermaid` から図解候補が返ってきたタイミングだけ `Mermaid Editor を開く` ボタンを有効化し、ユーザーに「図解できる状態」であることを示します。図解がない場合は常に `disabled` にしておき、無駄なクリックを防ぎます。

### 3-3. 環境変数を設定

`.env`ファイルを作成して、Azure OpenAIの認証情報を設定します。

```bash
cat > .env << 'ENV'
# Azure OpenAI 認証情報
ENDPOINT=https://your-resource-name.openai.azure.com/
SUBSCRIPTION_KEY=your-api-key-here
MODEL_NAME=gpt-5.1-chat
API_VERSION=2024-02-15-preview

# 開発環境フラグ
DEVELOPMENT=True
ENV
```

**各値の取得方法：**

| 項目 | 取得場所 |
|------|--------|
| **ENDPOINT** | Azure Portal → Azure OpenAIリソース → キーとエンドポイント |
| **SUBSCRIPTION_KEY** | 同上 |
| **MODEL_NAME** | デプロイ時に指定した名前（例: `gpt-5.1-chat`） |
| **API_VERSION** | `2024-02-15-preview` など最新バージョンを指定 |

**動作確認のワンライナー：**

```bash
uv run python - <<'PY'
from dotenv import load_dotenv
import os
load_dotenv()
for key in ("ENDPOINT", "SUBSCRIPTION_KEY", "MODEL_NAME", "API_VERSION"):
    print(key, "=>", os.getenv(key))
PY
```

4つすべての値が表示されれば `.env` の読み込みは問題ありません。空欄がある場合はスペルミスや改行漏れを疑ってください。

### 3-4. ローカルで動作確認

すべてのファイルを作成したら、ローカルでアプリケーションを起動します。

```bash
# 仮想環境がアクティベートされているか確認
(news-summarizer) ~/Desktop/news-summarizer $

# アプリケーションを起動
uv run app.py
```

**期待される出力：**
```
 * Serving Flask app 'main'
 * Debug mode: on
 * Running on http://127.0.0.1:5000
```

### 3-5. ブラウザで確認

1. `http://localhost:5000` にアクセス
2. ニュース本文を入力ボックスに貼り付け
3. **「要約する」**ボタンをクリック
4. 要約結果が表示されることを確認

**テスト用のニュース例：**
```
新型AIチップがGoogleから発表された。
このチップは従来比で10倍の処理速度を実現する。
価格は999ドルから予定されており、来年上半期に一般向けリリース予定。
業界では大きな注目を集めており、Microsoftも対抗製品の開発を進めているとのこと。
```

---

## Step 4: GitHubにコードをアップロード

ローカルでの動作が確認できたら、GitHubにコードをアップロードします。

### 4-1. GitHubで新規リポジトリを作成

1. [GitHub](https://github.com/)にサインイン
2. 右上のプロフィールアイコンをクリック
3. **Your repositories** → **New** をクリック
4. 以下を入力：
   - **Repository name**: `news-summarizer`
   - **Description**: `AI-powered news summarization app with Azure OpenAI`
   - **Visibility**: `Public`（共有用）or `Private`（非公開）を選択
   - **Initialize this repository with**: **チェックしない**（ローカルコードを優先）
5. **Create repository** をクリック

### 4-2. GitHubが表示するセットアップコードを実行

リポジトリ作成後、GitHubの画面に以下のような手順が表示されます：

```
…or push an existing repository from the command line
```

画面に表示されたコマンドをコピーして、ターミナルで実行します：

```bash
# ローカルリポジトリにリモート(GitHub)を設定
git remote add origin https://github.com/[ユーザー名]/news-summarizer-p.git

# mainブランチにリネーム（必要な場合）
git branch -M main

# 最初のコミットを作成
git add .
git commit -m "Initial commit: Add news summarizer application"

# GitHubにプッシュ
git push -u origin main
```

**コマンド実行時の流れ：**

1. `git add .` - すべてのファイルをステージング
2. `git commit -m "..."` - コミットメッセージ付きでコミット
3. `git push -u origin main` - GitHubのmainブランチにプッシュ

**初回実行時：**

GitHubの認証が求められる場合があります。以下のいずれかで対応してください：

**方法A: Personal Access Token (トークン認証) - 推奨**

1. GitHubで **Settings** → **Developer settings** → **Personal access tokens** をクリック
2. **Generate new token** をクリック
3. 以下を設定：
   - **Token name**: `git-cli`
   - **Expiration**: `90 days`
   - **Scopes**: `repo` (すべてチェック), `workflow` をチェック
4. **Generate token** をクリック
5. トークンをコピー（画面を離れるともう見えません）
6. ターミナルで `git push` 時にパスワードを聞かれたら、トークンをペースト

**方法B: SSH認証**

```bash
# SSH鍵を生成（まだない場合）
ssh-keygen -t ed25519 -C "your@email.com"

# 公開鍵をコピー
cat ~/.ssh/id_ed25519.pub

# GitHubにアクセス → Settings → SSH and GPG keys → New SSH key
# 上記でコピーした内容をペースト

# 次回からSSH URLを使用
git remote set-url origin git@github.com:[ユーザー名]/news-summarizer-p.git
```

### 4-3. プッシュの確認

ターミナルで以下のメッセージが表示されればOK：

```
Counting objects: 25, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (20/20), done.
Writing objects: 100% (25/25), 15.32 KiB | 3.06 MiB/s, done.
Total 25 (delta 0), reused 0 (delta 0), pack-reused 0
To https://github.com/[ユーザー名]/news-summarizer-p.git
 * [new branch]      main -> main
Branch 'main' set to track remote branch 'main' from 'origin'.
```

GitHubの画面をリロードすると、コードがアップロードされているはずです。

### 4-4. .envファイルの確認

**重要**: `.gitignore`に`.env`が記載されているか確認してください。

```bash
# .gitignore の内容を確認
cat .gitignore | grep -i "\.env"

# 出力例:
# .env
# .env.local
```

`.env`ファイルが`.gitignore`に含まれていれば、GitHubにアップロードされません。

もし誤ってアップロードしてしまった場合：

```bash
# ローカルキャッシュをクリア
git rm --cached .env

# .gitignore に追加
echo ".env" >> .gitignore

# コミット
git add .gitignore
git commit -m "Add .env to .gitignore"

# プッシュ
git push origin main
```

---

## Step 5: Azure App Serviceへのデプロイ

GitHubにコードがアップロードできたら、Azure App Serviceにデプロイします。

### 5-1. Azure PortalでApp Serviceを開く

1. [Azure Portal](https://portal.azure.com/)にサインイン
2. 検索バーで `news-summarizer-app` を検索
3. 作成したApp Serviceをクリック

### 5-2. デプロイセンターを設定（GitHub連携）

ここからは、GitHubリポジトリとAzure App Serviceを連携させ、自動デプロイを設定します。

#### ステップ1: デプロイセンターを開く

1. [Azure Portal](https://portal.azure.com/)にサインイン
2. 作成した **App Service** （`news-summarizer-app`）を開く
3. 左メニューから**デプロイセンター**を選択

#### ステップ2: ソースを GitHub に設定

1. **ソース**セクションで **GitHub** を選択
2. **GitHubアカウントで認可**をクリック
3. GitHubのログイン画面が表示されたら、ユーザー名とパスワードを入力

**⚠️ 初回のみ**: GitHub認可を求めるダイアログが表示されます。
**Authorize AzureAppService** をクリックして許可してください。

#### ステップ3: リポジトリ情報を設定

認可後、以下の項目が表示されます。それぞれを設定します：

| 項目 | 値 | 説明 |
|------|-----|------|
| **組織** | ご自分のGitHubユーザー名 | 例: `your-name` |
| **リポジトリ** | `news-summarizer` | Step 4で作成したリポジトリ名 |
| **ブランチ** | `main` | デプロイするブランチ |

**設定例:**
- 組織: `アカウント名`
- リポジトリ: `news-summarizer`
- ブランチ: `main`

#### ステップ4: 変更を保存

すべての設定を入力したら：

1. 画面下部の **保存** をクリック
2. 確認ダイアログで **OK** をクリック

**⏳ 初回デプロイ開始**: 数分待つと、自動的にGitHubからコードが取得されて、デプロイが開始されます。

### 5-3. デプロイ状況の確認

#### デプロイが実行中か確認

1. **デプロイセンター** → **ログ** タブをクリック
2. デプロイの進行状況をリアルタイムで確認

**進行状況の表示例：**
```
受信中...
処理中...
⏳ デプロイ完了中...
✅ 成功（2025-11-23 12:00:00）
```

#### デプロイ失敗時の確認

デプロイが失敗した場合：

1. ログ内のエラーメッセージを確認
2. **出力** をクリックして詳細を確認
3. [Step 7: トラブルシューティング](#step-7-トラブルシューティング)を参照

#### 成功の確認方法

✅ デプロイが成功したら、以下の確認をしてください：

```bash
# Azure CLIで App Service のデプロイ状態を確認
az webapp deployment list-publishing-profiles \
  --resource-group news-summarizer-rg \
  --name news-summarizer-app

# または、App Service ログを確認
az webapp log tail --resource-group news-summarizer-rg \
  --name news-summarizer-app
```

**成功のサイン:**
- ✅ ログに「Build successful」と表示
- ✅ 進捗状況が「100%」に
- ✅ ステータスが「Active」に変化

### 5-4. App Service に環境変数を設定

**重要**: ローカルの `.env` ファイルで設定した環境変数を、Azure App Service に設定する必要があります。
App Service は `.env` ファイルにアクセスできないため、Azure Portal で手動で設定します。

#### ステップ1: ローカルの .env ファイル内容を確認

まず、ローカルで設定した値を確認します：

```bash
# ローカルの .env ファイルの内容を表示
cat .env
```

**出力例：**
```
ENDPOINT=https://news-summarizer-openai.openai.azure.com/
SUBSCRIPTION_KEY=a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6
MODEL_NAME=gpt-5.1-chat
API_VERSION=2024-02-15-preview
```

これらの値をコピーしておきます。

#### ステップ2: Azure Portalで設定

1. [Azure Portal](https://portal.azure.com/)にサインイン
2. 作成した **App Service** （`news-summarizer-app`）を開く
3. 左メニューから**構成**を選択
4. **アプリケーション設定**タブをクリック
5. **+ 新しいアプリケーション設定**をクリック

#### ステップ3: 環境変数を1つずつ追加

以下の4つの変数をすべて追加します：

| 変数名 | ローカル .env の値 | 例 |
|--------|-----------------|-----|
| ENDPOINT | ENDPOINT の値 | `https://news-summarizer-openai.openai.azure.com/` |
| SUBSCRIPTION_KEY | SUBSCRIPTION_KEY の値 | `a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6` |
| MODEL_NAME | MODEL_NAME の値 | `gpt-5.1-chat` |
| API_VERSION | API_VERSION の値 | `2024-02-15-preview` |

> **コマンドライン派の方へ**: Azure CLI が使える場合は、以下のコマンドで一括設定できます。Portalでの手入力ミスを減らせるので、慣れてきたらこちらも活用してください。

```bash
az webapp config appsettings set \
  --resource-group news-summarizer-rg \
  --name news-summarizer-app \
  --settings \
    ENDPOINT=$(grep ENDPOINT .env | cut -d '=' -f2-) \
    SUBSCRIPTION_KEY=$(grep SUBSCRIPTION_KEY .env | cut -d '=' -f2-) \
    MODEL_NAME=$(grep MODEL_NAME .env | cut -d '=' -f2-) \
    API_VERSION=$(grep API_VERSION .env | cut -d '=' -f2-)
```

※ macOS/Linux 用の例です。PowerShell の場合は `$env:ENDPOINT = (Get-Content .env | Select-String ...)` など、お好みのやり方で値を渡してください。

**各変数の追加手順：**

1. **名前** に上表の「変数名」を入力
   - 例: `ENDPOINT`
2. **値** にローカルの `.env` から対応する値をペースト
   - 例: `https://news-summarizer-openai.openai.azure.com/`
3. **OK** をクリック
4. 次の変数を追加する場合は **+ 新しいアプリケーション設定** をクリック

**⚠️ 重要な注意：**

- **SUBSCRIPTION_KEY（APIキー）は絶対に他人に共有しないでください**
- Gitにコミットしたり、公開の場所に置かないこと
- Azure Portalでのみ安全に管理されます

#### ステップ4: 変更を保存

すべての環境変数を追加したら：

1. 画面上部の **保存** をクリック
2. 確認ダイアログで **続行** をクリック

**⏳ 変更が反映されるまで数分待ちます**

#### ステップ5: App Service を再起動

環境変数が確実に読み込まれるよう、App Service を再起動します：

```bash
# Azure CLI を使用した再起動
az webapp restart \
  --resource-group news-summarizer-rg \
  --name news-summarizer-app
```

または Azure Portal から：

1. App Service の**概要**タブをクリック
2. 上部の **再起動** をクリック

これで、Azure App Service がローカルと同じ環境変数を使用するようになります。

### 5-5. アプリケーションにアクセス

1. App Serviceの**概要**タブをクリック
2. **URL**をコピー
3. ブラウザで URL（例: `https://news-summarizer-app.azurewebsites.net/`）にアクセス

**おめでとうございます！アプリがAzureで実行されています！**

---

## Step 6: CI/CDパイプラインの構築

これからは、`main`ブランチへのpushで自動的にAzureにデプロイされるようにします。

### 6-1. GitHub Actions ワークフローファイルの作成

Azure App Serviceのデプロイセンター経由で自動ワークフローが生成される場合もありますが、ここではカスタマイズされたワークフローを手動で作成します。

`.github/workflows/deploy.yaml` ファイルを作成してください：

```yaml
name: Build and deploy Python app to Azure Web App - news-summarizer-app

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python version
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m venv antenv
          source antenv/bin/activate
          pip install -r requirements.txt
      - name: Upload artifact for deployment jobs
        uses: actions/upload-artifact@v4
        with:
          name: python-app
          path: |
            .
            !antenv/
  deploy:
    runs-on: ubuntu-latest
    needs: build
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Download artifact from build job
        uses: actions/download-artifact@v4
        with:
          name: python-app

      - name: Login to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZUREAPPSERVICE_CLIENTID_28CB3E3328EB4E3896DD240927C792F2 }}
          tenant-id: ${{ secrets.AZUREAPPSERVICE_TENANTID_128BA5EC54904CA3AEFB0BC19A4F5C9A }}
          subscription-id: ${{ secrets.AZUREAPPSERVICE_SUBSCRIPTIONID_B9B2E02872414B8D9000CF6BCA4B8C1A }}

      - name: Wait for SCM stability
        run: sleep 30

      - name: Deploy to Azure Web App
        uses: azure/webapps-deploy@v3
        with:
          app-name: 'news-summarizer-app'
          slot-name: 'Production'

      - name: Wait for deployment completion
        run: sleep 20s
```

**ワークフローファイルの説明：**

| セクション | 説明 |
|-----------|------|
| **on** | トリガー条件（`main`へのpush時に実行） |
| **env** | 環境変数の定義（App名やPythonバージョン） |
| **build** | ビルドジョブ（依存関係のインストールと検証） |
| **deploy** | デプロイジョブ（Azureへのアップロード） |

**主な流れ：**

1. ✅ コードをチェックアウト
2. ✅ Python環境をセットアップ
3. ✅ 依存パッケージをインストール
4. ✅ コード品質チェック（flake8）
5. ✅ アーティファクトを作成
6. ✅ Azureへデプロイ
7. ✅ デプロイ完了確認

### 6-2. GitHub Secrets の設定

GitHub Actions が Azure に認証するために、`AZURE_WEBAPP_PUBLISH_PROFILE` シークレットを設定する必要があります。

#### ステップ1: Azure Portal から公開プロファイルを取得

1. [Azure Portal](https://portal.azure.com/) にサインイン
2. **App Service** （`news-summarizer-app`）を開く
3. 上部の **公開プロファイルの取得** をクリック
4. XML形式のファイルがダウンロードされます

#### ステップ2: GitHub Secrets に追加

1. GitHubリポジトリを開く
2. **Settings** → **Secrets and variables** → **Actions** をクリック
3. **New repository secret** をクリック
4. 以下を入力：
   - **Name**: `AZURE_WEBAPP_PUBLISH_PROFILE`
   - **Value**: ダウンロードしたXMLファイルの全内容をペースト
5. **Add secret** をクリック

**⚠️ 重要な注意：**
- このシークレットには認証情報が含まれるため、絶対に公開しないこと
- GitHub Secrets は暗号化されて保存されます

### 6-3. パイプラインをテスト

コードを変更して自動デプロイをテスト：

```bash
# ローカルでテスト用の変更をコミット
echo "# CI/CD Pipeline Test" >> README.md

# Gitに追加
git add README.md

# コミット
git commit -m "Test CI/CD pipeline"

# GitHubにプッシュ
git push origin main
```

### 6-4. デプロイの自動実行を確認

1. GitHubリポジトリの **Actions** タブをクリック
2. 新しいワークフロー実行が表示される（`Build and deploy Python app...`）
3. ワークフロー名をクリックして詳細を確認

**ワークフロー実行画面の見方：**

```
✅ build          (3-5分)
  ├─ Checkout code
  ├─ Set up Python
  ├─ Install dependencies
  ├─ Check Python syntax
  └─ Upload artifact

✅ deploy         (2-3分)
  ├─ Download artifact
  ├─ Deploy to Azure Web App
  ├─ Health check
  └─ Deployment summary
```

**各ステップの意味：**

| ステップ | 状態 | 意味 |
|---------|------|------|
| 🟡 Running | 実行中 | 処理中 |
| ✅ Passed | 成功 | 正常完了 |
| ❌ Failed | 失敗 | エラー発生 |
| ⏭️ Skipped | スキップ | 条件により実行されない |

### 6-5. デプロイ失敗時の確認

ワークフローが失敗した場合：

1. 失敗したジョブをクリック
2. 赤いバツマークの付いたステップを確認
3. ステップをクリックしてログを確認

**よくあるエラーと対処法：**

#### エラー: `Authentication failed`

**原因**: `AZURE_WEBAPP_PUBLISH_PROFILE` が正しく設定されていない

**解決方法**:
```bash
# GitHub Secrets の設定を再確認
# Settings → Secrets and variables → Actions から確認
# XMLファイルが完全にペーストされているか確認
```

#### エラー: `uv pip install` が失敗する

**原因**: `requirements.txt` に問題がある、または uv が仮想環境を正しく認識していない

**解決方法**:
```bash
# ローカルで依存関係をテスト
uv pip install -r requirements.txt

# エラーが出た場合、パッケージのバージョンを確認
cat requirements.txt
```

#### エラー: `Deployment timed out`

**原因**: デプロイに時間がかかっている

**解決方法**:
- App Service のコンピュートリソースをスケールアップ
- 不要なファイルを `.github/workflows/deploy.yaml` の `package` から除外

### 6-6. デプロイ完了後の確認

✅ ワークフローが成功したら：

1. GitHubリポジトリの **Actions** タブで ✅ マークを確認
2. Azure Portal で App Service を開く
3. **概要** タブの **URL** にアクセス
4. アプリケーションが正常に動作していることを確認

**デプロイの完全な流れ：**

```
あなた: git push origin main
  ↓
GitHub: ワークフロー開始（Actions）
  ├─ build ジョブ実行
  │  ├─ 依存関係をインストール
  │  ├─ コード品質チェック
  │  └─ ビルド成功
  ├─ deploy ジョブ実行
  │  ├─ Azure に認証
  │  ├─ ファイルアップロード
  │  ├─ App Service 再起動
  │  └─ デプロイ完了
  ↓
Azure App Service: アプリケーション更新
  ↓
ユーザー: 新しいバージョンにアクセス可能
```

### 6-7. GitHub Actions ワークフローの監視

定期的にワークフローをチェックするための方法：

#### GitHub Notifications の設定

1. GitHubの **Settings** → **Notifications** へ移動
2. **Actions** セクションで通知設定を確認
3. 失敗時にメール通知を受け取る設定が可能

#### Badge の追加（オプション）

READMEにステータスバッジを追加：

```markdown
# News Summarizer

[![Build and deploy Python app to Azure App Service](https://github.com/[ユーザー名]/news-summarizer-p/actions/workflows/deploy.yaml/badge.svg)](https://github.com/[ユーザー名]/news-summarizer-p/actions/workflows/deploy.yaml)

このプロジェクトは自動デプロイされています。
```

**✅ これ以降、`main`ブランチへのpushで自動デプロイが実行されます。**

---

## Step 7: トラブルシューティング

このセクションでは、よくあるエラーと解決方法をまとめました。

### Web App が表示されない場合

**症状**: Azure App Service の URL にアクセスしても、アプリケーションが表示されない

#### 原因 1: スタートアップコマンドが設定されていない

**解決方法**:

1. Azure Portal → App Service（`news-summarizer-app`）を開く
2. 左メニューから **構成** をクリック
3. **一般設定** タブをクリック
4. **スタートアップコマンド** に以下を入力：

```
gunicorn --bind 0.0.0.0:8000 --workers 4 --timeout 120 wsgi:app
```

5. **保存** をクリック
6. App Service を **再起動**

**各パラメータの意味**:
- `--bind 0.0.0.0:8000` : すべてのインターフェースでポート 8000 をリッスン
- `--workers 4` : 4個のワーカープロセスを起動
- `--timeout 120` : リクエストタイムアウトを120秒に設定
- `wsgi:app` : WSGI アプリケーションエントリポイント

#### 原因 2: ホストが `localhost` に限定されている

**解決方法**:

`main.py` または `wsgi.py` が以下のように設定されていることを確認：

```python
app.run(host='0.0.0.0', port=port)  # ✅ 正しい
# app.run(host='localhost', port=port)  # ❌ 間違い
```

既に修正されています。

#### 原因 3: ログをアクセスしてエラーを確認

**Azure ポータルでログを確認**:

1. Azure Portal → App Service を開く
2. 左メニュー → **ログストリーム** をクリック
3. リアルタイムログを確認

**Azure CLI でログを確認**:

```bash
# リアルタイムログ表示
az webapp log tail --resource-group news-summarizer-rg --name news-summarizer-app

# ログを保存して確認
az webapp log download --resource-group news-summarizer-rg \
  --name news-summarizer-app \
  --log-file app-logs.zip
```

#### 原因 4: 環境変数が設定されていない

**確認方法**:

1. Azure Portal → App Service → **構成**
2. **アプリケーション設定** タブをクリック
3. 以下の4つが全て設定されているか確認：
   - `ENDPOINT`
   - `SUBSCRIPTION_KEY`
   - `MODEL_NAME`
   - `API_VERSION`

**もし不足していたら**:

1. **+ 新しいアプリケーション設定** をクリック
2. 各変数を追加
3. **保存** をクリック
4. App Service を **再起動**

### ローカル開発時のエラー

#### Error 1: `mmdc: command not found`

**原因**: Mermaid CLIがインストールされていない

**解決方法**:
```bash
npm install -g @mermaid-js/mermaid-cli
mmdc --version
```

#### Error 2: `Azure API error: InvalidAuthenticationTokenTenant`

**原因**: Azure OpenAIの認証情報が正しくない

**解決方法**:
1. `.env`ファイルの `ENDPOINT`, `SUBSCRIPTION_KEY` を確認
2. Azure PortalでコピーするときURLの最後に `/` が付いているか確認
3. APIキーが期限切れでないか確認

#### Error 3: `No module named 'flask'`

**原因**: 必要なパッケージがインストールされていない

**解決方法**:
```bash
uv pip install -r requirements.txt
```

#### Error 4: `Port 5000 is already in use`

**原因**: ポート5000を使用しているプロセスが存在

**解決方法**:
```bash
# 使用中のプロセスを確認（macOS/Linux）
lsof -i :5000

# 別のポートで起動
python main.py --port 5001
```

### GitHubプッシュ時のエラー

#### Error 5: `fatal: remote origin already exists`

**原因**: すでにリモートが設定されている

**解決方法**:
```bash
# 既存のリモートを確認
git remote -v

# 新しいリモートで置き換え
git remote set-url origin https://github.com/[ユーザー名]/news-summarizer-p.git
```

#### Error 6: `Authentication failed`

**原因**: GitHubの認証情報が正しくない

**解決方法**:

方法A: Personal Access Token を使用
```bash
# キャッシュされた認証情報をクリア
git credential reject
protocol=https
host=github.com

# 再度プッシュ（トークンを入力）
git push origin main
```

方法B: SSH認証に変更
```bash
git remote set-url origin git@github.com:[ユーザー名]/news-summarizer-p.git
git push origin main
```

### Azure デプロイ時のエラー

#### Error 7: `Deployment failed: Missing requirements.txt`

**原因**: `requirements.txt`がGitにコミットされていない

**解決方法**:
```bash
# requirements.txt をGitに追加
git add requirements.txt
git commit -m "Add requirements.txt"
git push origin main
```

#### Error 8: `Application Insights: No module named 'flask'`

**原因**: App Service上で依存パッケージがインストールされていない

**解決方法**:
```bash
# App Service を再起動
az webapp restart --resource-group news-summarizer-rg \
  --name news-summarizer-app
```

#### Error 9: Azure OpenAI API の 429 エラー（Rate Limit）

**原因**: API呼び出しの制限を超えている

**解決方法**:
1. Azure OpenAIのデプロイTPM（Tokens Per Minute）を増加
2. App Service のスケールアップ
3. キャッシング機能を実装

#### Error 10: `Application did not respond within the time limit`

**原因**: アプリケーション起動に時間がかかっている

**解決方法**:

1. **スタートアップコマンド内でのタイムアウト設定**:

```bash
gunicorn --bind 0.0.0.0:8000 --workers 4 --timeout 300 wsgi:app
```

`--timeout 300` で タイムアウトを300秒に拡張

2. **App Service のスケールアップ**:
   - Azure Portal → App Service プラン
   - **スケールアップ** をクリック
   - より大きなインスタンス（例: B1 以上）を選択

### ログの確認方法

#### ローカルログ

```bash
# Flask デバッグログを有効化
FLASK_ENV=development FLASK_DEBUG=1 python main.py
```

#### Azure ログ

```bash
# App Service のログをリアルタイム表示
az webapp log tail --resource-group news-summarizer-rg \
  --name news-summarizer-app

# または Kudu コンソールからアクセス
# URL: https://[app-name].scm.azurewebsites.net/
```

### デバッグチェックリスト

Web App が表示されない場合、以下を順番に確認してください：

- [ ] **ログストリームでエラーを確認**
  ```bash
  az webapp log tail --resource-group news-summarizer-rg --name news-summarizer-app
  ```

- [ ] **スタートアップコマンドが設定されているか確認**
  ```bash
  az webapp config show --resource-group news-summarizer-rg --name news-summarizer-app
  ```

- [ ] **環境変数が全て設定されているか確認**
  ```bash
  az webapp config appsettings list --resource-group news-summarizer-rg --name news-summarizer-app
  ```

- [ ] **requirements.txt にFlask と Gunicorn が含まれているか確認**
  ```bash
  grep -E "Flask|gunicorn" requirements.txt
  ```

- [ ] **main.py が `host='0.0.0.0'` で起動しているか確認**
  ```bash
  grep "host=" main.py
  ```

- [ ] **app.py または wsgi.py が存在するか確認**
  ```bash
  ls -la app.py wsgi.py
  ```

- [ ] **GitHub Actions が成功したか確認**
  - GitHub → Actions → 最新ワークフロー → ✅ 成功マーク

### Mermaid 図解エラーの解決

**症状**: 「Mermaid CLI がインストールされていません」というエラーが表示される

#### 原因

Azure App Service 環境では `mmdc (mermaid-cli)` コマンドが利用できません。これはセキュリティおよびリソース管理上の理由によるものです。

#### ✅ 解決方法

Mermaid 図解機能は **3つの方法** で利用できます：

##### 方法 1: ローカル環境で実行（最も推奨）

ローカル開発環境でアプリを実行すれば、図解の PNG 変換が正常に動作します。

```bash
# 仮想環境をアクティベート
source .venv/bin/activate

# ローカルで実行
python main.py

# ブラウザで http://localhost:5000 にアクセス
# → Mermaid 図解を PNG でダウンロード可能
```

##### 方法 2: Mermaid Live Editor を使用（推奨）

オンラインツール「Mermaid Live Editor」を使用して、図解を PNG で保存できます。

**手順**:
1. アプリで要約を生成
2. 「図をPNGで保存」をクリック
3. エラーメッセージ内のリンクをクリック: https://mermaid.live/
4. Mermaid コードをコピーペースト
5. **Download** ボタンで PNG を保存

**メリット**:
- オンラインで完結
- インストール不要
- インタラクティブに図を編集可能

##### 方法 3: Azure に npm をインストール（上級）

Azure App Service 内に npm をインストールすることで、mmdc を使用できます（非推奨）。

```bash
# Azure Kudu コンソール経由でインストール
# https://[app-name].scm.azurewebsites.net/DebugConsole

npm install -g @mermaid-js/mermaid-cli
```

**注意**:
- ⚠️ Azure の無料枠では容量制限に達する可能性
- ⚠️ 起動時間が増加
- ⚠️ パフォーマンスが低下する可能性

#### 推奨フロー

```
Azure Web App での要約生成
    ↓
図解として Mermaid コードを表示
    ↓
【方法1】ローカルで PNG 変換 / 【方法2】Online Editor で変換
    ↓
PNG ファイルを保存
```

---

## 最後に

このガイドでは、AI要約アプリをセットアップからAzureへのデプロイまで、完全に構築しました。

### 習得したスキル

✅ Python仮想環境の構築
✅ Flask Webアプリケーション開発
✅ Azure OpenAI API の統合
✅ GitHub へのコードアップロード
✅ Azure App Service へのデプロイ
✅ 自動デプロイメント（CI/CD）の構築
✅ クラウドアーキテクチャの基礎

### 次のステップ

このアプリを発展させるなら：

1. **認証機能の追加** - ユーザー登録・ログイン機能
2. **データベース連携** - 要約結果の永続化（Azure Cosmos DB）
3. **スケーリング** - 大規模トラフィック対応（オートスケーリング）
4. **監視・アラート** - Application Insights でのモニタリング
5. **APIゲートウェイ** - Azure API Management での公開

### コスト概算

**初年度の想定費用:**

| サービス | 月額 | 年額 |
|---------|------|------|
| App Service (Free) | ¥0 | ¥0 |
| Azure OpenAI (スタンダード) | ¥3,000-5,000 | ¥36,000-60,000 |
| GitHub (Personal) | ¥0 | ¥0 |
| **合計** | **¥3,000-5,000** | **¥36,000-60,000** |

**無料トライアル**: ¥22,500クレジット（3ヶ月）

---

**最後まで読んでいただきありがとうございました！**

このアプリが皆さんの学習の手助けになれば幸いです。
クラウド開発の世界を一緒に探求していきましょう！
